import base64
import datetime
import uuid
from typing import Dict

import jwt
from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.primitives.asymmetric import rsa


class JwtTokenGenerator:
    """
    A class that simulates a Keycloak server for generating JWT tokens.
    This class is used for testing purposes and provides methods to generate
    JWT tokens, retrieve OpenID configuration, and get JSON Web Key Set (JWKS).
    It uses the RS256 algorithm for signing the tokens and includes various
    claims in the payload such as expiration time, issuer, audience, subject,
    and user details.
    The generated tokens can be used to authenticate users in a simulated
    Keycloak environment.
    The class also provides methods to retrieve the OpenID configuration and
    JWKS for the fake Keycloak server.
    The JWKS contains the public key of the fake Keycloak server, which can be
    used to verify the signature of the generated JWT tokens.
    The class is initialized with default values for the issuer and client ID,
    but these can be overridden by passing different values to the constructor.
    The generated tokens are signed using a private key generated by the class,
    and the public key is included in the JWKS.
    The class is designed to be used in a testing environment where a real
    Keycloak server is not available or not needed. It provides a simple and
    lightweight alternative for generating JWT tokens and simulating Keycloak
    behavior.
    """

    def __init__(
        self,
        issuer: str = "http://localhost:8080/realms/codeflix",
        client_id: str = "codeflix-frontend",
    ):
        """
        Initialize the FakeKeycloak object.

        Args:
            issuer (str): The expected value of the "iss" claim in the JWT token.
                Defaults to "http://localhost:8080/realms/codeflix".
            client_id (str): The expected value of the "aud" claim in the JWT token.
                Defaults to "codeflix-frontend".
        """

        self.issuer = issuer
        self.client_id = client_id
        self.kid = "fake-key-id"

        self.key = rsa.generate_private_key(
            public_exponent=65537,
            key_size=2048,
        )
        self.private_key_pem = self.key.private_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PrivateFormat.PKCS8,
            encryption_algorithm=serialization.NoEncryption(),
        )
        self.public_key = self.key.public_key()
        self.public_key_pem = self.public_key.public_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PublicFormat.SubjectPublicKeyInfo,
        )

    def generate_token(
        self,
        user_info: Dict,
        expires_in_minutes: int = 60,
    ) -> str:
        """
        Generate a JWT token with the specified user information and expiration time.

        Args:
            user_info (Dict): A dictionary containing user information such as id,
                first name, last name, username, email, and roles.
            expires_in_minutes (int, optional): The number of minutes until the token expires.
                Defaults to 60 minutes.

        Returns:
            str: The encoded JWT token.

        The token includes claims such as expiration time, issued at time,
        issuer, audience, subject, and various user details. The token is signed
        using the RS256 algorithm with the generated private key.
        """

        now = datetime.datetime.now(tz=datetime.timezone.utc)
        exp = now + datetime.timedelta(minutes=expires_in_minutes)

        first_name = user_info.get("first_name", "")
        last_name = user_info.get("last_name", "")
        username = user_info.get("username", "")
        email = user_info.get("email", "")
        sub = user_info.get("id", str(uuid.uuid4()))
        jti = str(uuid.uuid4())

        payload = {
            "exp": int(exp.timestamp()),
            "iat": int(now.timestamp()),
            "jti": jti,
            "iss": self.issuer,
            "aud": "account",
            "sub": sub,
            "typ": "Bearer",
            "azp": self.client_id,
            "sid": str(uuid.uuid4()),
            "acr": "1",
            "allowed-origins": ["/*"],
            "realm_access": {"roles": user_info.get("realm_roles", [])},
            "resource_access": {
                "account": {"roles": user_info.get("resource_roles", [])}
            },
            "scope": "profile email",
            "email_verified": True,
            "name": f"{first_name} {last_name}".strip(),
            "preferred_username": username,
            "given_name": first_name,
            "family_name": last_name,
            "email": email,
        }

        headers = {
            "alg": "RS256",
            "typ": "JWT",
            "kid": self.kid,
        }

        encoded_token = jwt.encode(
            payload=payload,
            key=self.private_key_pem,
            algorithm="RS256",
            headers=headers,
        )

        return encoded_token

    def get_openid_configuration(self) -> Dict:
        """
        Gets the OpenID configuration.

        Returns:
            Dict: The OpenID configuration dictionary.
        """

        return {
            "issuer": self.issuer,
            "jwks_uri": f"{self.issuer}/protocol/openid-connect/certs",
        }

    def get_jwks(self) -> Dict:
        """
        Gets the JSON Web Key Set (JWKS) for the fake keycloak server.

        The JWKS contains the public key of the fake keycloak server. The public key is
        encoded in the JSON Web Key (JWK) format.

        Returns:
            Dict: The JWKS dictionary containing the public key.
        """

        numbers = self.public_key.public_numbers()

        def b64(n: int) -> str:
            """
            Encode an integer as a base64url-encoded string.

            The input integer is first converted to bytes in big-endian order. The bytes are
            then encoded using the base64url encoding scheme. The resulting string is then
            stripped of any trailing "=" characters and decoded from bytes to a UTF-8 string.

            Args:
                n (int): The integer to be encoded.

            Returns:
                str: The base64url-encoded string.
            """

            return (
                base64.urlsafe_b64encode(n.to_bytes((n.bit_length() + 7) // 8, "big"))
                .rstrip(b"=")
                .decode("utf-8")
            )

        jwk = {
            "kty": "RSA",
            "kid": self.kid,
            "use": "sig",
            "alg": "RS256",
            "n": b64(numbers.n),
            "e": b64(numbers.e),
        }

        return {"keys": [jwk]}


if __name__ == "__main__":
    keycloak = JwtTokenGenerator()

    user = {
        "id": "8ea04190-8495-415e-b557-5fbe91f53643",
        "username": "admin",
        "first_name": "admin",
        "last_name": "admin",
        "email": "admin@admin.com",
        "realm_roles": [
            "offline_access",
            "admin",
            "uma_authorization",
            "default-roles-codeflix",
        ],
        "resource_roles": [
            "manage-account",
            "manage-account-links",
            "view-profile",
        ],
    }

    token = keycloak.generate_token(user)
    print("\nğŸ” Token JWT:\n", token)
